#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"
#include "hardware/interp.h"
#include "osc.c"

// Input
#define CLK_PIN 22
#define LOAD_PIN 21
#define SER_READ 20

// Sound
#define FIRST_DAC_PIN 7
#define WAVETABLE_LENGTH 500
#define SAMPLE_RATE 100000

// volatile uint8_t wavetable[96] = {127, 135, 144, 152, 160, 168, 176, 183, 191, 198, 205, 211, 217, 223, 228, 233, 237, 241, 245, 248, 250, 252, 253, 254, 255, 254, 253, 252, 250, 248, 245, 241, 237, 233, 228, 223, 217, 211, 205, 198, 191, 183, 176, 168, 160, 152, 144, 135, 127, 119, 110, 102, 94, 86, 78, 71, 63, 56, 49, 43, 37, 31, 26, 21, 17, 13, 9, 6, 4, 2, 1, 0, 0, 0, 1, 2, 4, 6, 9, 13, 17, 21, 26, 31, 37, 43, 49, 56, 63, 71, 78, 86, 94, 102, 110, 119};


volatile int8_t wavetable[500] = {0, 2, 3, 5, 6, 8, 10, 11, 13, 14, 16, 17, 19, 21, 22, 24, 25, 27, 28, 30, 32, 33, 35, 36, 38, 39, 41, 42, 44, 45, 47, 48, 50, 51, 53, 54, 56, 57, 58, 60, 61, 63, 64, 65, 67, 68, 69, 71, 72, 73, 75, 76, 77, 78, 80, 81, 82, 83, 85, 86, 87, 88, 89, 90, 91, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 111, 112, 113, 114, 114, 115, 116, 116, 117, 117, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 126, 126, 126, 126, 126, 125, 125, 125, 124, 124, 124, 123, 123, 123, 122, 122, 121, 121, 120, 120, 119, 119, 118, 117, 117, 116, 116, 115, 114, 114, 113, 112, 111, 111, 110, 109, 108, 107, 106, 105, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 91, 90, 89, 88, 87, 86, 85, 83, 82, 81, 80, 78, 77, 76, 75, 73, 72, 71, 69, 68, 67, 65, 64, 63, 61, 60, 58, 57, 56, 54, 53, 51, 50, 48, 47, 45, 44, 42, 41, 39, 38, 36, 35, 33, 32, 30, 28, 27, 25, 24, 22, 21, 19, 17, 16, 14, 13, 11, 10, 8, 6, 5, 3, 2, 0, -2, -3, -5, -6, -8, -10, -11, -13, -14, -16, -17, -19, -21, -22, -24, -25, -27, -28, -30, -32, -33, -35, -36, -38, -39, -41, -42, -44, -45, -47, -48, -50, -51, -53, -54, -56, -57, -58, -60, -61, -63, -64, -65, -67, -68, -69, -71, -72, -73, -75, -76, -77, -78, -80, -81, -82, -83, -85, -86, -87, -88, -89, -90, -91, -93, -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -105, -106, -107, -108, -109, -110, -111, -111, -112, -113, -114, -114, -115, -116, -116, -117, -117, -118, -119, -119, -120, -120, -121, -121, -122, -122, -123, -123, -123, -124, -124, -124, -125, -125, -125, -126, -126, -126, -126, -126, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -127, -126, -126, -126, -126, -126, -125, -125, -125, -124, -124, -124, -123, -123, -123, -122, -122, -121, -121, -120, -120, -119, -119, -118, -117, -117, -116, -116, -115, -114, -114, -113, -112, -111, -111, -110, -109, -108, -107, -106, -105, -105, -104, -103, -102, -101, -100, -99, -98, -97, -96, -95, -94, -93, -91, -90, -89, -88, -87, -86, -85, -83, -82, -81, -80, -78, -77, -76, -75, -73, -72, -71, -69, -68, -67, -65, -64, -63, -61, -60, -58, -57, -56, -54, -53, -51, -50, -48, -47, -45, -44, -42, -41, -39, -38, -36, -35, -33, -32, -30, -28, -27, -25, -24, -22, -21, -19, -17, -16, -14, -13, -11, -10, -8, -6, -5, -3, -2};

// triangle volatile uint8_t wavetable[WAVETABLE_LENGTH] = {127, 132, 137, 142, 147, 153, 158, 163, 168, 173, 178, 183, 188, 193, 198, 204, 209, 214, 219, 224, 229, 234, 239, 244, 249, 255, 249, 244, 239, 234, 229, 224, 219, 214, 209, 204, 198, 193, 188, 183, 178, 173, 168, 163, 158, 153, 147, 142, 137, 132, 127, 122, 117, 112, 107, 102, 96, 91, 86, 81, 76, 71, 66, 61, 56, 51, 45, 40, 35, 30, 25, 20, 15, 10, 5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 51, 56, 61, 66, 71, 76, 81, 86, 91, 96, 102, 107, 112, 117, 122};

//volatile uint8_t wavetable[WAVETABLE_LENGTH] = {130, 158, 180, 203, 219, 231, 236, 240, 236, 230, 222, 210, 199, 185, 171, 159, 150, 139, 130, 123, 116, 112, 108, 108, 107, 108, 112, 114, 117, 121, 124, 126, 125, 125, 123, 123, 119, 116, 113, 110, 112, 111, 114, 117, 120, 126, 133, 142, 147, 156, 166, 176, 188, 197, 206, 211, 217, 217, 218, 210, 200, 185, 166, 149};

// volatile float notes[108] = {16.35, 17.32, 18.35, 19.45, 20.60, 21.83, 23.12, 24.50, 25.96, 27.50, 29.14, 30.87, 32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 49.00, 51.91, 55.00, 58.27, 61.74, 65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88, 523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77, 1046.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53, 2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96, 3322.44, 3520.00, 3729.31, 3951.07, 4186.01, 4434.92, 4698.63, 4978.03, 5274.04, 5587.65, 5919.91, 6271.93, 6644.88, 7040.00, 7458.62, 7902.13};
volatile uint32_t notes[108] = {4186, 4434, 4698, 4979, 5274, 5588, 5919, 6272, 6646, 7040, 7460, 7903, 8371, 8870, 9398, 9956, 10547, 11174, 11840, 12544, 13289, 14080, 14917, 15805, 16745, 17741, 18796, 19912, 21097, 22351, 23680, 25088, 26580, 28160, 29834, 31608, 33487, 35479, 37588, 39823, 42191, 44700, 47360, 50176, 53158, 56320, 59668, 63217, 66977, 70958, 75177, 79649, 84385, 89403, 94717, 100352, 106317, 112640, 119337, 126433, 133952, 141919, 150356, 159296, 168768, 178806, 189437, 200701, 212636, 225280, 238676, 252869, 267904, 283835, 300713, 318595, 337539, 357609, 378875, 401403, 425272, 450560, 477353, 505736, 535808, 567670, 601426, 637189, 675077, 715221, 757750, 802806, 850545, 901120, 954703, 1011474, 1071619, 1135340, 1202849, 1274376, 1350154, 1430438, 1515497, 1605614, 1701089, 1802240, 1909407, 2022945};

//volatile uint16_t notes[108] = {16, 17, 18, 19, 21, 22, 23, 25, 26, 28, 29, 31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 93, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902};


enum {
	ENV_ATTACK = 0,
	ENV_SUSTAIN,
	ENV_RELEASE
};


volatile struct env_t {
	int8_t sample;
	uint8_t state;
	uint32_t level;
	uint32_t attack_dx;
	uint32_t release_dx;

} env_a;

void env_init(volatile struct env_t* env)
{
	env->sample = 0;
	env->state = ENV_RELEASE;
	env->level = 0;
	env->attack_dx = 100;
	env->release_dx = 3;
}

//TODO rewrite state machine
void env_change_state(volatile struct env_t* env)
{
	switch(env->state)
	{
		case ENV_ATTACK:
			env->state = ENV_SUSTAIN;
			break;

		case ENV_SUSTAIN:
			env->state = ENV_RELEASE;
			env->level = 0xFF<<11;
			break;

		case ENV_RELEASE:
			env->state = ENV_ATTACK;
			env->level = 0;
			break;
	}
}

void env_gate(volatile struct env_t* env, bool gate)
{
	if(gate == true)
	{
		if(env->state == ENV_RELEASE)
		{
			env->state = ENV_ATTACK;
		}
	}
	else
	{
		env->state = ENV_RELEASE;
	}	
}

void env_set_attack(volatile struct env_t* env, uint32_t attack_time)
{
	env->attack_dx = 0xFF<<11 / attack_time;
}

void env_set_release(volatile struct env_t* env, uint32_t release_time)
{
	env->release_dx = 0xFF<<11 / release_time;
}

int8_t env_run(volatile struct env_t* env, int8_t input)
{
	if(env->state == ENV_ATTACK)
	{
		if (env->level >= 0xFF<<11)
			env_change_state(env);
		else
			env->level += env->attack_dx;
	}

	if(env->state == ENV_RELEASE)
	{
		if (env->level < env->release_dx)
			env->level = 0;
		else
			env->level -= env->release_dx;
	}

	bool is_neg = false;
	volatile uint32_t temp;

	if(input < 0)
	{
		is_neg = true;
		temp = input * -1;
	}
	else
		temp = input;
	
	temp = ((temp<<8) * (env->level>>11)) >> 16;
	int8_t out = temp;

	if(is_neg == true)
		 out *= -1;

	env->sample = out;
	return env->sample;
}

// Write sample to DAC. This function is called at sampling rate freq
bool write_sample(struct repeating_timer *t)
{
	int8_t pre_val = osc_run(&osc_a);
	uint8_t val = env_run(&env_a, pre_val) + 127;

	// Write sample to DAC
	int32_t mask = val << FIRST_DAC_PIN;
	gpio_put_masked(255 << FIRST_DAC_PIN, mask);	
	return true;
}

int main() {

	// Init stdio
	// stdio_init_all();

	// ADC
	adc_init();
	adc_gpio_init(26);
	adc_select_input(0);

	// Init input multiplexing pins
	uint16_t input_bank = 45;
	gpio_init(2);
	gpio_set_dir(2, GPIO_OUT);
	gpio_init(3);
	gpio_set_dir(3, GPIO_OUT);

    // Init DAC output pins. TODO use gpio_set_dir_masked instead of for loop
    for (int gpio = FIRST_DAC_PIN; gpio < FIRST_DAC_PIN + 8; gpio++) {
        gpio_init(gpio);
        gpio_set_dir(gpio, GPIO_OUT);
    }

	// Init synth
	osc_init(&osc_a, wavetable, WAVETABLE_LENGTH);
	env_init(&env_a);

	// Timer for sample rate. Gets called every 10us (100.000kHz)
	struct repeating_timer samplerate_timer;
	add_repeating_timer_us(-10, write_sample, NULL, &samplerate_timer);

    while (true) {

		// Input takes 5 ADC samples and makes an average
		uint16_t acum = 0;		

		for(int i = 0; i < 5; i++)
		{	
			acum += adc_read();
		}

		acum /= 5;
		uint16_t number = (acum + 170) / 341;

		// Update frequency and gate to synth
		if (number > 1)
		{
//			uint16_t freq = notes[number + input_bank];
			env_gate(&env_a, true);
//			if(freq != osc_a.freq)
//			{
				osc_set_freq(&osc_a, notes[number + input_bank]);
//			}
		}
		else
		{
			env_gate(&env_a, false);
			env_a.state = ENV_RELEASE;
		}

		// Input multiplexing
		if (input_bank == 45)
		{
			gpio_put(2, false);
			gpio_put(3, true);
			input_bank = 55;
		}
		else
		{
			gpio_put(2, true);
			gpio_put(3, false);
			input_bank = 45;
		}

		sleep_ms(20);
    }

    return 0;
}

